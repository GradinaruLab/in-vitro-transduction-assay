# Basic imports
import numpy as np
import pandas as pd

import tqdm
import os
import glob

import datetime

# Image processing tools
import skimage.io
from skimage import (color, feature, filters, measure, morphology, segmentation, util)
import skimage.feature
import skimage.filters
import skimage.filters.rank
from skimage.filters import threshold_otsu
import skimage.morphology
import skimage.segmentation
from skimage.segmentation import watershed
from scipy import ndimage as ndi
import scipy.signal

def sig_thresh_finder(histogram, bins, desired_thresh = 1000):
    ''' 
    Searches through a list of second derivatives for the bin value at which the
    previous derivative was greater than desired thresh and the current derivative is less
    than the desired thresh. If there are multiple events where this occurs, they are stored in a list and the largest one is used as a threshold. 
    '''
    
    past_i = 0
    index = 0
    thresh = []
    
    result = np.where(histogram == np.max(histogram))
    
    peak_val = bins[result[0][0]]
    
    for i in histogram:

        # Look for the threshold location
        if (past_i > desired_thresh and i <= desired_thresh) and (bins[index] > peak_val):

            # Interpolate to find the appropriate bin equal to the desired thresh
            threshold = bins[index-1] + (bins[index] - bins[index-1])*(desired_thresh - past_i)/(i-past_i)
            thresh.append(threshold)

        # Reset the parameters
        past_i = i
        index += 1
    
    if thresh != []:
        
        thresh_val = np.min(thresh)

        return(thresh_val)
    
    else:
        past_i = 0
        index = 0
        
        for i in dn_dk:
            # Look for the threshold location
            if (past_i > desired_thresh*0.2 and i <= desired_thresh*0.2) and (bins[index] > peak_val):

                # Interpolate to find the appropriate bin equal to the desired thresh
                threshold = bins[index-1] + (bins[index] - bins[index-1])*(desired_thresh - past_i)/(i-past_i)
                thresh.append(threshold)

            # Reset the parameters
            past_i = i
            index += 1

        thresh_val = np.min(thresh)

        return(thresh_val)

def bf_thresh_finder(histogram, bins, desired_thresh = 10000, standard = True):
    
    past_i = 0
    index = 0
    thresh = []
    
    if standard == True:
        for i in histogram:

            # Look for the threshold location
            if past_i > desired_thresh and i <= desired_thresh:
                
                # Interpolate to find the appropriate bin equal to the desired thresh
                threshold = bins[index-1] + (bins[index] - bins[index-1])*(desired_thresh - past_i)/(i-past_i)
                thresh.append(threshold)

            # Reset the parameters
            past_i = i
            index += 1
    
        return(np.min(thresh))
        
    else: 
        # Loop through the second derivatives 
        for i in histogram:

            # Look for the threshold location
            if past_i < desired_thresh and i >= desired_thresh:

                # Interpolate to find the appropriate bin equal to the desired thresh
                threshold = bins[index-1] + (bins[index] - bins[index-1])*(desired_thresh - past_i)/(i-past_i)
                thresh.append(threshold)

            # Reset the parameters
            past_i = i
            index += 1
        
        return(np.min(thresh))

def brightness_counter(im_labeled, im_pos):
    '''
    Brightness counter is a function that produces a list of brightness values for up to one thousand cells in an image. 
    The brightness values is a sum of the intensity for a given labelled object.
    
    Parameters
    im_labeled: An image array with each independant object labeled with a separate value generated by skimage.measure.label
    im_pos: The result of the autofluorescence subtraction
    
    Returns
    cell_list: list of cells selected for analysis
    cell_intensities: list of cell intensities
    '''
    
    # Determine whether down-sampling is required 
    if np.max(im_labeled) > 1000:
        # Create a list of the cells to quantify the brightness in using a random number generator without replacement  
        cell_list = np.random.choice(np.arange(1, np.max(im_labeled)), 1000, replace=False)
    else:
        # If there are less than 100 cells, create a list of all the cells to access
        cell_list = np.arange(1, np.max(im_labeled) + 1)
    
    cell_intensities = {}
    
    # Simplify labels to a Nx2 array, with an array of i and an array of j indices
    nonzero_inds = im_labeled.nonzero()
    
    # Fill in an array of the cell labels for later boolean logic
    labels = [im_labeled[i,j] for i,j in zip(nonzero_inds[0], nonzero_inds[1])]
    
    # Instantiate dictionary
    cell_intensities = {}
 
    # Loop through the prepared cell list
    for count_value in cell_list:
        
        # Get a list of i and of j indices
        label_bool = (labels == count_value)
        inds = (nonzero_inds[0][label_bool], nonzero_inds[1][label_bool])
        
        # In the positive image, sum over the whole cell to get its intensity
        intensities = im_pos[inds]
        cell_intensity = np.sum(intensities)/len(intensities)
        
        # Append this to a list of all cell intensities
        cell_intensities[str(count_value)] = cell_intensity
        
    return(cell_list, cell_intensities)

def remove_large_objects(im, max_size = 1000, connectivity = 1):
    ''' Function to remove large objects in an image. Useful for removing large autofluorescent features.
    Parameters:
    im: a binary image array to remove the large objects from
    max_size: the maximum sized object to keep in the image
    connectivity: required pixel connectivity for contiguity
    
    Returns: 
    out: Binary image array with large ojects removed
    '''
    
    out = im.copy()
    
    selem = ndi.generate_binary_structure(im.ndim, connectivity)
    ccs = np.zeros_like(im, dtype=np.int32)
    ndi.label(im, selem, output=ccs)

    component_sizes = np.bincount(ccs.ravel())
    
    too_big = component_sizes > max_size
    too_big_mask = too_big[ccs]
    out[too_big_mask] = 0

    return(out)

def brightfield_segmentation(im_bf, gauss_sigma = 30, truncate = 0.35, dark_thresh = 10000, light_thresh = 3000, disk_radius = 2):
    # Apply a gaussian blur to determine the intensity change in the background
    im_bg = skimage.filters.gaussian(im_bf, sigma = gauss_sigma, truncate = truncate)
    
    # Subtract the background from the BF image to obtain a smoother signal with reduced background variation
    im_no_bg = im_bf - im_bg
    
    # Compute the histogram of the image intensities
    hist_bin = skimage.exposure.histogram(im_no_bg)
    hist, bins = hist_bin

    # Using the thresh_finder function, determine the threshold that enables separation of dark objects from the background by setting standard to false
    thresh_lower = bf_thresh_finder(hist, bins, desired_thresh = dark_thresh, standard = False)
    
    # Determine the dark areas
    bf_thresh = (im_no_bg < thresh_lower)
    
    # Remove large objects
    #bf_thresh = remove_large_objects(bf_thresh, max_size = 1000)
    
    # Using the thresh_finder function, determine the threshold that enables separation of bright objects from the background
    thresh_upper = bf_thresh_finder(hist, bins, desired_thresh = light_thresh, standard = True)
    
    # Combine the light areas to the dark areas
    bf_thresh += (im_no_bg > thresh_upper)
    
    # Fill in the areas of the image using a scanning disk
    binary_closed = skimage.morphology.closing(bf_thresh, 
                                               skimage.morphology.disk(radius = disk_radius))
    
    #Determine the total area of cells
    total_area = sum(sum(binary_closed))
    
    return(binary_closed, total_area)

def signal_segmentation(im_sig, gauss_sigma = 100, sig_thresh = 1000, min_size = 5):
    # Apply a gaussian blur to determine the intensity change in the background
    im_bg = skimage.filters.gaussian(im_sig, sigma = gauss_sigma)
    
    # Subtract the background from the BF image to obtain a smoother signal with reduced background variation
    im_no_bg = im_sig - im_bg
    
    # Compute the histogram of the image intensities
    hist_bin = skimage.exposure.histogram(im_no_bg)
    hist, bins = hist_bin

    # Using the thresh_finder function, determine the threshold that enables separation of bright objects from the background
    thresh = sig_thresh_finder(hist, bins, desired_thresh = sig_thresh)
    
    # Determine the dark areas
    sig_thresh = (im_no_bg > thresh)
    
    # Remove large objects
    #bf_thresh = remove_large_objects(bf_thresh, max_size = 1000)
    
    # Remove small objects
    sig_thresh = skimage.morphology.remove_small_objects(sig_thresh, min_size = 5)
    
    #Determine the total area of cells
    total_area = sum(sum(sig_thresh))
    
    return(sig_thresh, total_area)

def in_vitro_quantification(im_bf, im_sig, bf_gauss_sigma = 30, truncate = 0.35, dark_thresh = 10000, light_thresh = 3000, disk_radius = 2, sig_gauss_sigma = 100, sig_thresh = 1000, min_size = 5, h_max = 0.01, collected_percentiles = [5,95]):
    brightfield_areas, total_area = brightfield_segmentation(im_bf, bf_gauss_sigma, truncate, dark_thresh, light_thresh, disk_radius)
    signal_areas, signal_total_area = signal_segmentation(im_sig, sig_gauss_sigma, sig_thresh, min_size)
    
    original_sig = signal_areas*im_sig
    
    total_brightness = np.sum(np.sum(original_sig))
    
    #Determine the local maxima, considering pixels above the originally obtained threshold
    image_max = skimage.morphology.h_maxima(im_sig, h_max)

    #Label the maxima
    maxima = skimage.measure.label(image_max)

    #Using the labeled maxima, watershed the intensity in the original image
    labels = watershed(signal_areas, maxima, mask = signal_areas)

    im_labeled, n_labels = skimage.measure.label(labels, background=0, return_num=True)
    
    cell_list, cell_intensity_list = brightness_counter(im_labeled, im_sig)
    
    if cell_list != []:
        
        median = np.median(list(cell_intensity_list.values()))
        nintyfifth = np.percentile(list(cell_intensity_list.values()), collected_percentiles[1])
        fifth = np.percentile(list(cell_intensity_list.values()), collected_percentiles[0])

        return(n_labels, cell_list, cell_intensity_list, total_area, signal_total_area, total_brightness, median, nintyfifth, fifth)
    
    else: 
        return(n_labels, cell_list, cell_intensity_list, total_area, signal_total_area, total_brightness, [], [], [])
        
def workflow(df_lut, directory, output_file, input_file = None):
    if input_file == None:
        # Initialize a dataframe
        df = pd.DataFrame(columns=['Date',
                           'Round',
                           'Plate',
                           'Well',
                           'Count',
                           'Cells Quantified',
                           'Brightness List',
                           'Bright Field Area',
                           'Signal Area',
                           'Total Brightness',
                           'Median Cell Brightness',
                            '90% Confidence Interval'])

    else:
        df = pd.read_csv(input_file, comment='#')
    
    # Cycle through the rows in the look up table
    for index, row in tqdm.tqdm(df_lut.iterrows(), total=df_lut.shape[0]):

        #Get the file location:
        if row['Well'] < 10:
            well_directory = directory + '/round_' + str(row['Round']) + '/plate_' + str(row['Plate']) + '/XY0' + str(row['Well']) +'/'
        else:
            well_directory = directory + '/round_' + str(row['Round']) + '/plate_' + str(row['Plate']) + '/XY' + str(row['Well']) +'/'

        #Collect all the images from the final folder (there should be four images), although only two will be used.
        file_list = glob.glob(well_directory + '*.tif')
        
        # If there are less than four images, the code jumps to the next folder
        if len(file_list) == 4:

            # Initialize the images
            im_sig = skimage.img_as_float(skimage.io.imread(file_list[0])[:,:,1])
            im_bf = skimage.img_as_float(skimage.io.imread(file_list[1])[:,:])
            
        elif len(file_list) == 5:
            
            im_sig = skimage.img_as_float(skimage.io.imread(file_list[0])[:,:,1])
            im_bf = skimage.img_as_float(skimage.io.imread(file_list[3])[:,:])
            
        else:
            continue
        
        # Collect data from the image by running it through the cellseg.quant package. For more information, see that code.  
        n_cells, cell_list, cell_intensity_list, bf_area, signal_area, total_brightness, median, nintyfifth, fifth  = in_vitro_quantification(im_bf, im_sig)

        temp_df = pd.DataFrame.from_dict([{'Date' : datetime.datetime.now(),
                        'Round': row['Round'],
                        'Plate': row['Plate'],
                        'Well': row['Well'], 
                        'Count' : int(n_cells),
                        'Cells Quantified' : str(cell_list), 
                        'Brightness List': str(cell_intensity_list), 
                        'Bright Field Area': bf_area,
                        'Signal Area': signal_area,
                        'Total Brightness': total_brightness,
                        'Median Cell Brightness': median, 
                        '90% Confidence Interval': [fifth, nintyfifth]}])

        # Write all the information into a tidy dataframe
        df = pd.concat([df,temp_df],
                       ignore_index=True)

        # Save the dataframe
        df.to_csv(output_file, index=False)

        
    return(df)